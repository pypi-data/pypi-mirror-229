Metadata-Version: 2.1
Name: pytzen
Version: 0.0.130
Summary: PYTZEN
Home-page: https://www.pytzen.com
Author: PYTZEN
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE

# `pytzen`
----

## Disclaimer:
This library is offered 'as-is' with **no official support, maintenance, or warranty**. Primarily, `pytzen` is an experimentation and learning platform, which may not be apt for production settings. Users are encouraged to delve into the library but should note that the developers won't actively address arising issues.

## Code Access:
The associated GitHub repository is private. Direct access to the source code's versioning or issue tracking is restricted. However, the source code is available on this page and in the **Download files** section:
- **Source Distribution**: `pytzen-*.tar.gz`
- **Built Distribution**: `pytzen-*-py3-none-any.whl`

## Usage Caution:
We are not liable for issues stemming from the library's usage in production environments. Users should extensively test and vet the library in a safe space before expansive implementation.

----

# `ZenGenerator`
Tailored for data scientists, the ZenGenerator addresses the specific demands of dynamic model applications within the Jupyter Notebook ecosystem. Here's what it offers:

- **Dynamic Class Creation**: With just a dictionary input detailing attributes, effortlessly generate and instantiate Python classes.
- **Auto-Documentation**: Each dynamically formed class comes with automated documentation, ensuring clarity and coherence.
- **Rapid Prototyping**: Experience unrestricted class definition, immediate model testing, and tweaksâ€”all in real-time.
- **Config-Driven Design**: It caters to classes birthed from configuration details or external datasets.
- **System Extensions**: It's a boon for enriching prevailing systems via new class plugins or extensions.
- **Jupyter Export**: Seamlessly export your Jupyter Notebook with the newly created class as both source code and markdown, facilitating a smooth transition between coding and documentation.

In summary, ZenGenerator molds a wholly functional, auto-documented Python class within Jupyter Notebook, primed for swift deployment and dissemination.

## Usage

### Libraries


```python
import sys
from pprint import pprint
import inspect
sys.path.append('/home/pytzen/lab/pytzen/src')
from pytzen.generator import ZenGenerator
from pytzen.zen.class_generator import ClassPattern
from pytzen.zen.docstring_composer import DocumentationGenerator
from pytzen.zen.notebook_exporter import NotebookConverter

zen = ZenGenerator()
GeneratedClass = zen.cls
```


```python
def is_jupyter_notebook():
    try:
        ipython = get_ipython()
        print(f"IPython environment detected. Configuration: {ipython.config}")  # Debug statement
        if 'IPKernelApp' in ipython.config:
            app_name = ipython.config.IPKernelApp.get('parent_appname', "")
            print(f"App name: {app_name}")  # Debug statement
            if app_name == 'ipython-notebook':
                return True
    except NameError as e:
        print("NameError:", e)  # Debug statement
        return False
    except AttributeError as e:
        print("AttributeError:", e)  # Debug statement
        return False

    return False

print("Calling function...")  # Debug statement
if is_jupyter_notebook():
    print("Running inside a Jupyter Notebook!")
else:
    print("Not running inside a Jupyter Notebook!")
print("Function call complete.")  # Debug statement

```

    Calling function...
    IPython environment detected. Configuration: {'IPKernelApp': {'ip': '127.0.0.1', 'stdin_port': 9008, 'control_port': 9006, 'hb_port': 9005, 'shell_port': 9007, 'transport': 'tcp', 'iopub_port': 9009, 'connection_file': '/home/pytzen/.local/share/jupyter/runtime/kernel-v2-8058FuDtA16v34yx.json'}, 'Session': {'signature_scheme': 'hmac-sha256', 'key': b'0413361a-81f1-4e8b-b4f6-0c839c43f821'}, 'Completer': {'use_jedi': False}}
    App name: 
    Not running inside a Jupyter Notebook!
    Function call complete.


### `ZenGenerator` Documentation


```python
print(zen.__doc__)
```

    
        The ZenGenerator facilitates the dynamic generation of class 
        structures based on specific patterns provided via JSON. 
        It is particularly designed to work with Jupyter notebooks.
    
        Attributes:
        - file_name (str): The name of the Jupyter notebook currently in 
        use.
        - dict_class (dict): A dictionary containing details about the new 
        class pattern.
        - outputs (dict): Attributes (outputs) of the class derived from the 
        class pattern.
        - methods (dict): Methods of the class derived from the class 
        pattern.
        - cls (ClassPattern): A dynamically generated class structure.
    
        Methods:
        - find_file_name(directory='.'): Determines the name of the current 
        Jupyter notebook.
        - generate_subclass(subclass): Dynamically generates subclasses for 
        'outputs' or 'methods' based on the provided subclass parameter.
        - create_method(method_name): A decorator for linking blueprint 
        methods and runtime wrapper for method behavior validation.
        - export(path_md=None, path_py=None, conversions=None): Exports the 
        current Jupyter notebook in Markdown and Python formats.
    
        Note: This class leverages external classes such as 
        `DocumentationGenerator`, `ClassPattern`, and `NotebookConverter` 
        from the 'pytzen.zen' package to fulfill its functionality.
        


### Notebook File Name


```python
print(zen.file_name)
```

    generator_doc


### Class Design Pattern


```python
pprint(zen.dict_class)
```

    {'description': 'Docstring explaining the class.',
     'inputs': {'another_input': 'Docstring explaining another input.',
                'some_input': 'Docstring explaining the input.'},
     'methods': {'another_method': 'Docstring explaining another method.',
                 'some_method': 'Docstring explaining the method.'},
     'outputs': {'another_output': 'Docstring explaining another output.',
                 'some_output': 'Docstring explaining the output.'}}


### Class Route


```python
print(zen.cls)
```

    <class 'pytzen.zen.class_generator.ClassPattern.generate_class.<locals>.ClassDesign'>


### Class Documentation Before Instantiation


```python
print(zen.cls.__doc__)
```

    
                Dynamic blueprint representing the target class structure.
    
                This class serves as a blueprint for the desired class 
                structure defined in `dict_class`.
                It initializes attributes based on the 'inputs' section of 
                the `dict_class` and expects all of them to be provided 
                during instantiation. Moreover, it dynamically binds methods 
                defined in the 'methods' section of the `dict_class` to the 
                instance.
    
                Attributes:
                    - Based on the 'inputs' section of `dict_class`.
    
                Methods:
                    - Dynamically bound based on the 'methods' section of 
                    `dict_class`.
                


### Outputs Subclass Route


```python
print(zen.cls.out)
```

    <class 'pytzen.generator.subclass'>


### Methods Subclass Route


```python
print(zen.cls.met)
```

    <class 'pytzen.generator.subclass'>


### Create First Method


```python
@zen.create_method('some_method')
def _(GeneratedClass):
    GeneratedClass.out.some_output = 'I was produced inside the decorated function for some_method.'
    return 'Some_method was created by the decorator.'
```

### Try Instantiation With Missing Inputs


```python
try:
    gen_class = GeneratedClass(some_input='arg needed')
except Exception as err:
    print(err)
```

    These inputs are missed: {'another_input'}.
    These methods are missed: {'another_method'}.


### Try Non Expected Input


```python
try:
    gen_class = GeneratedClass(some_input='arg needed',
                               non_expected='out of the box')
except Exception as err:
    print(err)
```

    Invalid attribute 'non_expected' for this class.


### Try Instantiation With Missing Methods


```python
try:
    gen_class = GeneratedClass(some_input='arg needed', 
                               another_input='another arg needed')
except Exception as err:
    print(err)
```

    These methods are missed: {'another_method'}.


### Try Non Designed Method


```python
try:
    @zen.create_method('non_designed_method')
    def _(GeneratedClass):
        ...
except Exception as err:
    print(err)
```

    'non_designed_method' not found in methods of ClassDesign.


### Complete Designed Methods


```python
@zen.create_method('another_method')
def _(GeneratedClass):
    GeneratedClass.out.another_output = 'I was produced inside the decorated function for another_method.'
    GeneratedClass.attribute = 'I was created dynamically to be used in the class.'
    return 'Another_method was created by the decorator.'
```


```python
print(inspect.getsource(GeneratedClass))
```

            class ClassDesign:
                """
                Dynamic blueprint representing the target class structure.
    
                This class serves as a blueprint for the desired class 
                structure defined in `dict_class`.
                It initializes attributes based on the 'inputs' section of 
                the `dict_class` and expects all of them to be provided 
                during instantiation. Moreover, it dynamically binds methods 
                defined in the 'methods' section of the `dict_class` to the 
                instance.
    
                Attributes:
                    - Based on the 'inputs' section of `dict_class`.
    
                Methods:
                    - Dynamically bound based on the 'methods' section of 
                    `dict_class`.
                """
    
                def __init__(self, **kwargs):
                    # Use the DocumentationGenerator to create a docstring 
                    # for the class from the JSON description.
                    gen_doc = DocumentationGenerator(json_obj=dict_class)
                    self.__doc__ = gen_doc.docstring
    
                    # Override default attribute values with those provided 
                    # during instantiation.
                    given_inputs = []
                    for k, v in kwargs.items():
                        # Check if the attribute is allowed in this class.
                        if k in dict_class['inputs']:
                            setattr(self, k, v)
                            given_inputs.append(k)
                        else:
                            # Raise an error if an unexpected attribute 
                            # is provided.
                            error = f"Invalid attribute '{k}' for this class."
                            raise ValueError(error)
                    
                    # Info about missing inputs
                    missed = (set(dict_class['inputs']) - set(given_inputs))
                    if missed:
                        print(f'These inputs are missed: {missed}.')
    
                    # Dynamically attach methods to the class based on the 
                    # 'methods' in the class dictionary.
                    methods_defined = []
                    for method_name in dict_class['methods']:
                        met_class = getattr(self.met, method_name, None)
                        if met_class and hasattr(met_class, 'exec'):
                            # Get the method implementation.
                            method = getattr(met_class, 'exec')
                            # Assign the method's documentation.
                            method.__doc__ = dict_class['methods'][method_name]
                            # Attach the method to our class.
                            setattr(self, method_name, method)
                            methods_defined.append(method_name)
    
                    # Info about missing methods
                    missed = (set(dict_class['methods']) - set(methods_defined))
                    if missed:
                        print(f'These methods are missed: {missed}.')
    


### New Class Documentation After Instantiation


```python
gen_class = GeneratedClass(some_input='arg needed', 
                           another_input='another arg needed')
print(gen_class.__doc__)
```

    {
      "description": "Docstring explaining the class.",
      "inputs": {
        "some_input": "Docstring explaining the input.",
        "another_input": "Docstring explaining another input."
      },
      "outputs": {
        "some_output": "Docstring explaining the output.",
        "another_output": "Docstring explaining another output."
      },
      "methods": {
        "some_method": "Docstring explaining the method.",
        "another_method": "Docstring explaining another method."
      }
    }


### Check New Class Objects


```python
print(gen_class.some_method())
```

    Some_method was created by the decorator.



```python
print(gen_class.another_method())
```

    Another_method was created by the decorator.



```python
print(gen_class.out.some_output)
```

    I was produced inside the decorated function for some_method.



```python
print(gen_class.out.another_output)
```

    I was produced inside the decorated function for another_method.



```python
print(gen_class.attribute)
```

    I was created dynamically to be used in the class.



```python
print(gen_class.out.__doc__)
```

    TODO: subclasses docstring



```python
print(gen_class.met.__doc__)
```

    TODO: subclasses docstring


----


# Source Code

## `ZenGenerator`


```python
print(inspect.getsource(ZenGenerator))
```

    class ZenGenerator:
        """
        The ZenGenerator facilitates the dynamic generation of class 
        structures based on specific patterns provided via JSON. 
        It is particularly designed to work with Jupyter notebooks.
    
        Attributes:
        - file_name (str): The name of the Jupyter notebook currently in 
        use.
        - dict_class (dict): A dictionary containing details about the new 
        class pattern.
        - outputs (dict): Attributes (outputs) of the class derived from the 
        class pattern.
        - methods (dict): Methods of the class derived from the class 
        pattern.
        - cls (ClassPattern): A dynamically generated class structure.
    
        Methods:
        - find_file_name(directory='.'): Determines the name of the current 
        Jupyter notebook.
        - generate_subclass(subclass): Dynamically generates subclasses for 
        'outputs' or 'methods' based on the provided subclass parameter.
        - create_method(method_name): A decorator for linking blueprint 
        methods and runtime wrapper for method behavior validation.
        - export(path_md=None, path_py=None, conversions=None): Exports the 
        current Jupyter notebook in Markdown and Python formats.
    
        Note: This class leverages external classes such as 
        `DocumentationGenerator`, `ClassPattern`, and `NotebookConverter` 
        from the 'pytzen.zen' package to fulfill its functionality.
        """
        
        def __init__(self, json_path=None) -> None:
            
            # Find the name of the Jupyter notebook currently in use.
            self.file_name = self.find_file_name()
    
            # Use the provided JSON path to extract new 
            # class pattern details.
            dict_gen = DocumentationGenerator(json_path=json_path)
            self.dict_class = dict_gen.json_obj
            
            # Store class attributes (outputs) and methods separately.
            self.outputs = self.dict_class['outputs']
            self.methods = self.dict_class['methods']
            
            # Dynamically generate the structure of the class.
            cls_gen = ClassPattern(dict_class=self.dict_class)
            self.cls = cls_gen.ClassDesign
            
            # Populate the class with attribute and method blueprints.
            self.cls.out = self.generate_subclass(subclass='outputs')
            self.cls.met = self.generate_subclass(subclass='methods')
    
        def find_file_name(self, directory='.'):
            """
            Determines the name of the current Jupyter notebook.
    
            Parameters:
            - directory (str): The directory where the notebook resides. 
            Defaults to the current directory.
    
            Returns:
            - str: The name of the notebook without its file extension.
    
            Raises:
            - ValueError: If there isn't exactly one notebook in the 
            directory.
            """
            
            # Get a list of all Jupyter notebook files in the 
            # current directory.
            nb_files = [f for f in os.listdir(directory) if f.endswith('.ipynb')]
    
            # Expecting a single notebook, so return its name 
            # (without the file extension).
            if len(nb_files) == 1:
                return nb_files[0].split('.')[0]
            else:
                # If not exactly one, raise an error.
                raise ValueError("Please let one saved notebook in the folder.")
    
        def generate_subclass(self, subclass):
            """
            Dynamically generates subclasses for either 'outputs' or 
            'methods', based on the provided subclass parameter.
    
            Parameters:
            - subclass (str): Type of the subclass to generate 
            ('outputs' or 'methods').
    
            Returns:
            - type: A dynamically generated subclass.
            """
            
            # Placeholder for collecting subclass details.
            dict_subclass = {}
            # Choose the subclass type, if ouputs or methods.
            subclass_objects = (self.methods if subclass == 'methods' 
                                else self.outputs)
            
            for name, desc in subclass_objects.items():
                # Create documentation for each subclass item.
                subclass_items = DocumentationGenerator(json_obj=desc)
                desc = subclass_items.docstring
                
                # Represent each method as a type, with its documentation.
                dict_subclass[name] = type(name, (object,), {'__doc__': desc})
                
            # Create a dynamic class 'methods' with the defined methods.
            generated_cubclass = type('subclass', (object,), dict_subclass)
            
            # Assign documentation to the subclass.
            generated_cubclass.__doc__ = """TODO: subclasses docstring"""
    
            return generated_cubclass
    
        def create_method(self, method_name):
            """
            Returns a decorator to link blueprint methods. The decorator 
            provides a runtime wrapper to validate and possibly modify the 
            method behavior based on the class's blueprint.
    
            Parameters:
            - method_name (str): The name of the method to link.
    
            Returns:
            - function: A decorator function.
    
            Raises:
            - AttributeError: If the given method name isn't found in the 
            methods of the class blueprint.
            """
            
            # Define the primary decorator to link blueprint methods.
            def decorator(func):
                
                # A runtime wrapper to validate and possibly modify 
                # method behavior.
                def wrapper(*args, **kwargs):
                    
                    # Keep track of original attributes to detect 
                    # unauthorized changes later.
                    backup_attributes = set(self.cls.out.__dict__.keys())
                    
                    # Call the original function.
                    result = func(self.cls, *args, **kwargs)
                    
                    # Identify any unauthorized new attributes 
                    # added by the function.
                    added_attributes = (
                        set(self.cls.out.__dict__.keys()) - backup_attributes)
                    
                    # Validate the new attributes against the blueprint.
                    for attr in added_attributes:
                        if attr not in self.cls.outputs:
                            cls = self.cls.__name__
                            e = f"Attribute '{attr}' is not allowed in {cls}.att"
                            delattr(self.cls.out, attr)
                            raise AttributeError(e)
        
                    return result
    
                # Connect the wrapper to the actual method in the blueprint.
                nested_method = getattr(self.cls.met, method_name, None)
                if nested_method:
                    nested_method.exec = wrapper
                else:
                    cls = self.cls.__name__
                    error = f"'{method_name}' not found in methods of {cls}."
                    raise AttributeError(error)
    
                return wrapper
    
            return decorator
        
        def export(self, path_md=None, path_py=None, conversions=None):
            """
            Exports the current Jupyter notebook to different formats, 
            primarily Markdown and Python.
    
            Parameters:
            - path_md (str, optional): The path to save the exported 
            Markdown file.
            - path_py (str, optional): The path to save the exported 
            Python file.
            - conversions (list, optional): A list of desired output 
            formats. Example: ['md', 'py']
    
            Note:
            - If the 'py' format is specified in the conversions list, 
            the 'zen.export()' string will be removed from the 
            exported Python script.
            """
            
            # Convert the notebook to both Markdown and Python formats.
            converter = NotebookConverter(
                notebook_name=self.file_name, 
                path_md=path_md, 
                path_py=path_py,
                conversions=conversions
            )
            # Remove export function from exported python script
            if 'py' in converter.conversions:
                with open(converter.path_py, 'r') as file:
                    file_contents = file.read()
                    file_contents = file_contents.replace('zen.export()', '')
                with open(converter.path_py, 'w') as file:
                    file.write(file_contents)
    


## `ClassPattern`


```python
print(inspect.getsource(ClassPattern))
```

    class ClassPattern:
        """
        A class responsible for dynamically generating a blueprint of 
        a target class.
    
        The `ClassPattern` takes a dictionary representation of a class's 
        desired structure, including its inputs (attributes) and methods. 
        It then produces a dynamic blueprint of the target class, which 
        can be used to validate and instantiate the target class based 
        on this pattern.
    
        Attributes:
        - dict_class (dict): The dictionary describing the desired structure 
        of the target class.
        - ClassDesign (type): A dynamically generated class serving as the 
        blueprint for the target class.
    
        Note:
        The dynamic blueprint class (i.e., `ClassDesign`) expects all 
        attributes mentioned in 'inputs' to be provided during 
        instantiation. Additionally, it dynamically binds methods 
        defined in the 'methods' section of the `dict_class` to the 
        instance, allowing them to be invoked as regular methods.
        """
    
        def __init__(self, dict_class):
            # Store the dictionary that describes the desired 
            # class structure.
            self.dict_class = dict_class
    
            # Generate the class blueprint based on the given 
            # class structure.
            self.ClassDesign = self.generate_class()
    
        def generate_class(self):
            """
            Dynamically generates the blueprint of the target class based on 
            the provided class structure.
    
            The method creates an inner class `ClassDesign` that represents 
            the blueprint of the target class. 
            This inner class expects all attributes mentioned in the 
            'inputs' section of the `dict_class` to be provided during 
            instantiation. It also dynamically binds methods defined in 
            the 'methods' section of the `dict_class` to the instance.
    
            Returns:
            - type: The dynamically generated `ClassDesign` class.
            """
    
            dict_class = self.dict_class
    
            # Inner class representing the dynamic blueprint of our 
            # target class.
            class ClassDesign:
                """
                Dynamic blueprint representing the target class structure.
    
                This class serves as a blueprint for the desired class 
                structure defined in `dict_class`.
                It initializes attributes based on the 'inputs' section of 
                the `dict_class` and expects all of them to be provided 
                during instantiation. Moreover, it dynamically binds methods 
                defined in the 'methods' section of the `dict_class` to the 
                instance.
    
                Attributes:
                    - Based on the 'inputs' section of `dict_class`.
    
                Methods:
                    - Dynamically bound based on the 'methods' section of 
                    `dict_class`.
                """
    
                def __init__(self, **kwargs):
                    # Use the DocumentationGenerator to create a docstring 
                    # for the class from the JSON description.
                    gen_doc = DocumentationGenerator(json_obj=dict_class)
                    self.__doc__ = gen_doc.docstring
    
                    # Override default attribute values with those provided 
                    # during instantiation.
                    given_inputs = []
                    for k, v in kwargs.items():
                        # Check if the attribute is allowed in this class.
                        if k in dict_class['inputs']:
                            setattr(self, k, v)
                            given_inputs.append(k)
                        else:
                            # Raise an error if an unexpected attribute 
                            # is provided.
                            error = f"Invalid attribute '{k}' for this class."
                            raise ValueError(error)
                    
                    # Info about missing inputs
                    missed = (set(dict_class['inputs']) - set(given_inputs))
                    if missed:
                        print(f'These inputs are missed: {missed}.')
    
                    # Dynamically attach methods to the class based on the 
                    # 'methods' in the class dictionary.
                    methods_defined = []
                    for method_name in dict_class['methods']:
                        met_class = getattr(self.met, method_name, None)
                        if met_class and hasattr(met_class, 'exec'):
                            # Get the method implementation.
                            method = getattr(met_class, 'exec')
                            # Assign the method's documentation.
                            method.__doc__ = dict_class['methods'][method_name]
                            # Attach the method to our class.
                            setattr(self, method_name, method)
                            methods_defined.append(method_name)
    
                    # Info about missing methods
                    missed = (set(dict_class['methods']) - set(methods_defined))
                    if missed:
                        print(f'These methods are missed: {missed}.')
    
            return ClassDesign
    


## `DocumentationGenerator`


```python
print(inspect.getsource(DocumentationGenerator))
```

    class DocumentationGenerator:
        """
        Generates a documentation string from a provided JSON object 
        or path.
        
        Given a JSON object or the path to a JSON file, this class converts
        the content into a formatted string representation suitable for use 
        as a docstring. If no specific JSON object or path is provided, 
        it attempts to find and load the first JSON file in the current 
        directory.
        
        Attributes:
            json_obj (dict): Python dictionary representation of the JSON 
            content.
            json_path (str): Path to the JSON file, if used.
            width (int): Width for formatting the documentation's text.
            indentation (int): Indentation level for JSON representation 
            in the docstring.
            docstring (str): Generated documentation string from the JSON 
            content.
    
        Methods:
            find_json_path(directory='.') -> str:
                Finds the path of a JSON file in the given directory.
            
            open_json() -> dict:
                Reads and parses the content of a JSON file into a 
                dictionary.
    
            generate() -> str:
                Converts the JSON content to a formatted docstring.
        """
        
        def __init__(self, json_obj=None, json_path=None, 
                     width=68, indentation=2):
            
            # If a json_obj (Python dictionary) isn't provided, 
            # it'll be loaded from the json_path later.
            self.json_obj = json_obj
            
            # Path to the JSON file from which data might be loaded.
            self.json_path = json_path
            
            # Setting the width for formatting the documentation's text.
            self.width = width
            
            # Indentation level for formatting the JSON representation.
            self.indentation = indentation
            
            # If no direct json_obj is provided, load it from a file.
            if not json_obj:
                if not json_path:
                    # If no path is provided, try to find the JSON file 
                    # automatically.
                    self.json_path = self.find_json_path()
                
                # Read the JSON content from the provided or found path.
                self.json_obj = self.open_json()
            
            # Convert the JSON object to a formatted docstring.
            self.docstring = self.generate()
    
        def find_json_path(self, directory='.') -> str:
            """
            Finds the path of a JSON file in the given directory.
    
            Searches the specified directory for JSON files. If only one
            JSON file is found, it returns its path. Otherwise, raises 
            an error if no specific path is provided and multiple 
            JSON files are found.
    
            Parameters:
                directory (str, optional): Directory to search for the JSON 
                files. Defaults to the current directory.
    
            Returns:
                str: Path of the located JSON file.
    
            Raises:
                ValueError: If no specific path is provided and multiple 
                            JSON files exist in the directory.
            """
            
            # Find all JSON files in the given directory.
            json_files = [f for f in os.listdir(directory) 
                          if f.endswith('.json')]
    
            # If only one JSON file is found, return its path.
            if len(json_files) == 1:
                return os.path.join(directory, json_files[0])
            else:
                # Raise an error if no specific path is provided and 
                # multiple JSON files exist.
                raise ValueError(
                    "Please declare a path in the class instance.")
            
        def open_json(self) -> dict:
            """
            Reads and parses the content of a JSON file into a dictionary.
        
            Uses the json_path attribute to open and read the content 
            of the corresponding JSON file. The content is then parsed 
            into a Python dictionary.
        
            Returns:
                dict: Dictionary representation of the JSON file content.
            """
    
            # Open and read the JSON file.
            with open(self.json_path, 'r') as json_file:
                # Parse the JSON content to a Python dictionary.
                json_obj = json.load(json_file)
    
            return json_obj
        
        def generate(self) -> str:
            """
            Converts the JSON content to a formatted docstring.
    
            Takes the loaded JSON content, either from a provided object 
            or read from a file, and converts it into a string 
            representation formatted to the specified width and indentation.
            This formatted string is intended to be suitable for use as a 
            docstring.
    
            Returns:
                str: Formatted string representation of the JSON content.
            """
            
            # Convert the Python dictionary (JSON object) to a string 
            # representation.
            doc = json.dumps(self.json_obj, indent=self.indentation)
            
            # Ensure each line of the docstring doesn't exceed 
            # the set width.
            doc = [textwrap.fill(line, width=self.width) 
                   for line in doc.splitlines()]
            
            # Apply the format function to finalize the 
            # docstring's appearance.
            return '\n'.join(doc)
    


## `NotebookConverter`


```python
print(inspect.getsource(NotebookConverter))
```

    class NotebookConverter:
        """
        Converts Jupyter notebooks to various formats including Markdown 
        and Python.
    
        This class enables the conversion of Jupyter notebooks 
        (.ipynb files) into desired formats, primarily Markdown (.md) and 
        Python (.py) script files. 
        The user can provide specific paths for the output or default paths 
        will be used based on the notebook name.
    
        Attributes:
            notebook_name (str): Name of the Jupyter notebook to be 
            converted.
            path_md (str, optional): Desired output path for the Markdown 
            file. Defaults to 'README.md' in the current directory.
            path_py (str, optional): Desired output path for the Python 
            script. Defaults to a '.py' file with the same base name as the 
            notebook in the current directory.
            conversions (list, optional): List of desired output formats. 
            Supported values are 'md' and 'py'. Defaults to both 
            ['md', 'py'].
    
        Raises:
            FileNotFoundError: If the specified notebook does not exist in 
            the current directory.
    
        Methods:
            export_format(): Converts the notebook content to a specified 
            format and writes it to a file.
            to_markdown(): Converts the notebook to a Markdown format and 
            writes to the specified or default path.
            to_python(): Converts the notebook to a Python script and 
            writes to the specified or default path.
        """
    
        def __init__(self, conversions=['md', 'py'], notebook_name=None, 
                     path_md=None, path_py=None):
            
            # If the provided notebook_name doesn't have a '.ipynb' 
            # extension, add it.
            if not notebook_name.endswith('.ipynb'):
                notebook_name += '.ipynb'
            
            # Check if the notebook exists in the current directory.
            if not os.path.exists(notebook_name):
                raise FileNotFoundError(
                    f"The notebook {notebook_name} does not exist.")
                
            # Store the notebook's name, Markdown, and Python paths for 
            # later conversion.
            self.notebook_name = notebook_name
            self.path_md = path_md
            self.path_py = path_py
            self.conversions = conversions
            
            # Automatically convert the notebook to Markdown and Python 
            # formats.
            if 'md' in self.conversions:
                self.to_markdown()
            if 'py' in self.conversions:
                self.to_python()
    
        def export_to_format(self, exporter, output_path):
            """
            Converts the notebook content to a specified format and writes 
            it to a file.
    
            Given an exporter (either for Markdown or Python) and an output 
            path, this private method reads the notebook's content, converts 
            it to the desired format, and writes the converted content to 
            the specified output path.
    
            Args:
                exporter (nbconvert.Exporter): An instance of a notebook 
                exporter, either MarkdownExporter or PythonExporter.
                output_path (str): Path where the converted notebook 
                content should be saved.
    
            Note:
                This is a private method and should not be called directly. 
                It's used by the `to_markdown` and `to_python` methods.
            """        
            # Read the notebook's content and convert it to the desired 
            # format.
            body, _ = exporter.from_notebook_node(
                nbformat.read(self.notebook_name, as_version=4))
            
            # Write the converted content to the specified output path.
            with open(output_path, "w") as f:
                f.write(body)
    
        def to_markdown(self):
            """
            Converts the notebook to Markdown format.
    
            If no output path for the Markdown file is provided during the 
            class instantiation, it defaults to 'README.md' in the current 
            directory. The method uses the MarkdownExporter from the 
            `nbconvert` module to perform the conversion.
    
            Raises:
                FileNotFoundError: If the specified notebook does not exist.
    
            Returns:
                None. The converted content is written to the specified or 
                default path.
            """
            # If no Markdown path is provided, set a default path as 
            # 'README.md' in the current directory.
            if not self.path_md:
                self.path_md = os.path.join(os.getcwd(), 'README.md')
                
            # Use the MarkdownExporter to convert the notebook to 
            # Markdown format.
            exporter = MarkdownExporter()
            self.export_to_format(exporter, self.path_md)
            
            print(f"Exported to markdown at {self.path_md}")
    
        def to_python(self):
            """
            Converts the notebook to a Python script format.
    
            If no output path for the Python script is provided during the 
            class instantiation, it derives one from the notebook's name. 
            The method uses the PythonExporter from the `nbconvert` module 
            to perform the conversion.
    
            Raises:
                FileNotFoundError: If the specified notebook does not exist.
    
            Returns:
                None. The converted content is written to the specified or 
                default path.
            """
    
            # If no Python script path is provided, derive it from the 
            # notebook's name.
            if not self.path_py:
                notebook_basename = os.path.splitext(self.notebook_name)[0]
                self.path_py = os.path.join(
                    os.getcwd(), f'{notebook_basename}.py')
                
            # Use the PythonExporter to convert the notebook to a Python 
            # script format.
            exporter = PythonExporter()
            self.export_to_format(exporter, self.path_py)
            
            print(f"Exported to python script at {self.path_py}")
    



```python
zen.export(conversions=['md'], path_md='/home/pytzen/lab/pytzen/README.md')
```

    Exported to markdown at /home/pytzen/lab/pytzen/README.md

