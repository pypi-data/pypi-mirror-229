# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import pydantic

from .....core.api_error import ApiError
from .....core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from .....core.jsonable_encoder import jsonable_encoder
from .....core.remove_none_from_dict import remove_none_from_dict
from ...errors.bad_request_error import BadRequestError
from ...errors.forbidden_error import ForbiddenError
from ...errors.internal_server_error import InternalServerError
from ...errors.not_implemented_error import NotImplementedError
from ...errors.too_many_requests_error import TooManyRequestsError
from ...types.proxy_request_body_method import ProxyRequestBodyMethod

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class ProxyClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def request_post(
        self,
        *,
        url: typing.Optional[str] = OMIT,
        method: typing.Optional[ProxyRequestBodyMethod] = OMIT,
        path: typing.Optional[str] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        body: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        account_id: str,
    ) -> None:
        """
        Parameters:
            - url: typing.Optional[str]. The base url of the request

            - method: typing.Optional[ProxyRequestBodyMethod]. The method of the request

            - path: typing.Optional[str]. The path of the request including any query paramters

            - headers: typing.Optional[typing.Dict[str, typing.Any]]. The headers to send in the request

            - body: typing.Optional[typing.Dict[str, typing.Any]]. The body of the request

            - account_id: str. The account identifier
        """
        _request: typing.Dict[str, typing.Any] = {}
        if url is not OMIT:
            _request["url"] = url
        if method is not OMIT:
            _request["method"] = method
        if path is not OMIT:
            _request["path"] = path
        if headers is not OMIT:
            _request["headers"] = headers
        if body is not OMIT:
            _request["body"] = body
        _response = self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "unified/proxy"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_dict({**self._client_wrapper.get_headers(), "x-account-id": account_id}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 501:
            raise NotImplementedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncProxyClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def request_post(
        self,
        *,
        url: typing.Optional[str] = OMIT,
        method: typing.Optional[ProxyRequestBodyMethod] = OMIT,
        path: typing.Optional[str] = OMIT,
        headers: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        body: typing.Optional[typing.Dict[str, typing.Any]] = OMIT,
        account_id: str,
    ) -> None:
        """
        Parameters:
            - url: typing.Optional[str]. The base url of the request

            - method: typing.Optional[ProxyRequestBodyMethod]. The method of the request

            - path: typing.Optional[str]. The path of the request including any query paramters

            - headers: typing.Optional[typing.Dict[str, typing.Any]]. The headers to send in the request

            - body: typing.Optional[typing.Dict[str, typing.Any]]. The body of the request

            - account_id: str. The account identifier
        """
        _request: typing.Dict[str, typing.Any] = {}
        if url is not OMIT:
            _request["url"] = url
        if method is not OMIT:
            _request["method"] = method
        if path is not OMIT:
            _request["path"] = path
        if headers is not OMIT:
            _request["headers"] = headers
        if body is not OMIT:
            _request["body"] = body
        _response = await self._client_wrapper.httpx_client.request(
            "POST",
            urllib.parse.urljoin(f"{self._client_wrapper.get_base_url()}/", "unified/proxy"),
            json=jsonable_encoder(_request),
            headers=remove_none_from_dict({**self._client_wrapper.get_headers(), "x-account-id": account_id}),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 400:
            raise BadRequestError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 429:
            raise TooManyRequestsError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 500:
            raise InternalServerError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        if _response.status_code == 501:
            raise NotImplementedError(pydantic.parse_obj_as(typing.Any, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
