# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_utils.ipynb.

# %% auto 0
__all__ = ['call_across_lines', 'len_pad', 'len_lpad', 'len_rpad', 'titlify', 'indent', 'does_match_len', 'is_valid_chars',
           'is_cardinality', 'has_single_char', 'is_np_hline', 'is_rest_title', 'is_rest_transition', 'nabove',
           'nbelow', 'nsurround', 'surrounding', 'find_first_title', 'get_doctitle', 'find_end_of_def',
           'rest_directive', 'rest_auto_label_footnote', 'footnotify', 'make_note_str', 'make_section_str',
           'make_inheritance_separator', 'make_deprecated_str']

# %% ../nbs/01_utils.ipynb 4
import inspect, string
from dataclasses import  _KW_ONLY_TYPE

# %% ../nbs/01_utils.ipynb 5
from indoc.const import (
    # class related
    ABSTRACTMETHOD, ISABSTRACTMETHOD,

    # strings
    DDOT, DCLN, SPACE, 

    # explicit numpy section    
    NUMPY_SECTIONS, 
    # reST
    REST_NOTE, REST_MATH, REST_WARNING,
    REST_DEPRECATED, REST_AUTO_FOOTNOTE, 
    REST_LABEL_FOOTNOTE,

)

# %% ../nbs/01_utils.ipynb 8
def call_across_lines(fn: callable, lines: str, *args, **kwargs) -> str:
    sep = kwargs.pop('sep', '\n')    
    lines = lines.split(sep) if isinstance(lines, str) else lines
    res = [fn(line, *args, **kwargs) for line in lines]
    return f'{sep}'.join(res)

# %% ../nbs/01_utils.ipynb 10
def len_pad(s: str, chars: str = SPACE) -> int:
    '''Calculates the total padding length of a string.'''
    return len(s) - len(s.strip(chars))

def len_lpad(s: str, chars: str = SPACE) -> int:
    '''Calculates the left padding length of a string.'''
    return len(s) - len(s.lstrip(chars))

def len_rpad(s: str, chars: str = SPACE) -> int:
    '''Calculates the right padding length of a string.'''
    return len(s) - len(s.rstrip(chars))

# %% ../nbs/01_utils.ipynb 12
def titlify(*strs: tuple[str]) -> tuple[str]:
    '''Capitalizes the first letter of each word in a string.
    Parameters
    ----------
    strs : tuple[str]
        A tuple of strings to make each word capitalized.

    Returns
    -------
    strs : list[str]
        A tuple of capitalized strings.

    Examples
    --------
    >>> # NOTE: this is functionally equivalent to the lambda function below
    >>> return tuple(map(lambda s: string.capwords(s), strs))
    '''
    
    return tuple(map(lambda s: s.title(), strs))

def indent(s: str, n: int = 4, c: str = SPACE) -> str:
    '''Indents a string with the given number of spaces.
    Parameters
    ----------
    s : str
        The string to indent.
    n : int, default: 4
        The number of spaces to indent.
    c : str, default: ' '
        The character to use for indentation.

    Returns
    -------
    s : str
        The indented string.

    Examples
    --------
    >>> # NOTE: this is functionally equivalent to fstring below
    >>> return f'{(n * c)}{s}'
    '''
    
    if '\n' in s:
        return call_across_lines(indent, lines=s, n=n, c=c)
    return s.rjust(len(s) + n, c)


# %% ../nbs/01_utils.ipynb 14
def does_match_len(s: str, o: str) -> bool:
    '''Checks if two strings have the same length.'''
    return len(s) == len(o)

def is_valid_chars(s: str, chars: str = string.punctuation) -> bool:
    '''Checks if a string only contains characters from a set of valid characters.'''
    return all(c in chars for c in s)

def is_cardinality(s: str, n: int = 1) -> bool:
    '''Checks if a string is composed of `n` number of unique characters.'''
    return len(set(s)) == n

def has_single_char(s: str) -> bool:
    '''Checks if a string is composed of a single unique character.'''
    return is_cardinality(s, 1)

# %% ../nbs/01_utils.ipynb 16
def is_np_hline(sec: str, line: str):
    '''Checks if a line is a valid NumPy style horizontal line for a section.'''
    return len(sec) == len(line) and all(c == '-' for c in line) 


def is_rest_title(s: str, o: str, chars: str = string.punctuation, strip: bool = True) -> bool:
    '''Checks if a line is a valid reStructuredText title or subtitle
    
    Examples
    --------
    >>> # NOTE: this is functionally equivalent to util functions below
    >>> return (does_match_len(s, o) and is_valid_chars(o, chars) and is_cardinality(o, 1))
    '''
    if strip: 
        s, o = s[:].strip(), o[:].strip()
    return len(s) == len(o) and all(c in chars for c in o) and len(set(o)) == 1

def is_rest_transition(s: str, n: int = 4, chars: str = string.punctuation) -> bool:
    '''
    Checks if a line has a transition of n or more repeated punctuation characters in a row.

    Parameters
    ----------
    s : str 
        A single line of text
    n : int 
        The minimum number of repeated characters.
    chars : str, default: string.punctuation
        A string of characters to check for transitions.

    Returns:
    result : bool 
        True if the line has a transition, otherwise False.

    Examples
    --------
    >>> # NOTE: this is a more concise version of the below function, but it's slower
    >>> pattern = f"[{re.escape(string.punctuation)}]{{{n},}}"
    >>> return bool(re.search(pattern, line))
    '''
    bad_chars = set(chars)
    too_short = n - 1 # if the line is shorter than n, it can't have a transition
    for i in range(len(s) - too_short):
        substr = s[i:i+n]
        subset = set(substr) # unique characters in the substring
        if subset <= bad_chars and len(subset) == 1: # NOTE set_a <= set_b means set_a is a subset of set_b
            return True            
    return False

# %% ../nbs/01_utils.ipynb 18
def nabove(lines: list[str], i: int, n: int = 1) -> list[str]:
    '''Returns the `n` lines above the current line `i`.'''
    return lines[(i - n) : i]

def nbelow(lines: list[str], i: int, n: int = 1) -> list[str]:
    '''Returns the `n` lines below the current line `i`.'''
    return lines[(i + 1) : (i + 1) + n]

def nsurround(lines: list[str], i: int, n: int = 1) -> (str, str):
    '''Returns the `n` lines above and below the current line `i`.'''
    above, below = nabove(lines, i, n), nbelow(lines, i, n)    
    return above, below

def surrounding(lines: list[str], i: int) -> (str, str):
    '''Returns the immediately surrounding lines above and below the current line `i`.'''
    above, below = nabove(lines, i, 1), nbelow(lines, i, 1)
    above = above[0] if len(above) else ''
    below = below[0] if len(below) else ''
    return above, below

def find_first_title(lines: list[str]) -> str:
    '''Finds the first title in a list of lines.'''
    for i, line in enumerate(lines):
        if line.strip() in NUMPY_SECTIONS:                    
            above, below = surrounding(lines, i)
            is_title = is_rest_title(line, above) and is_rest_transition(below)
            is_subtitle = is_rest_title(line, below)
            if is_title or is_subtitle:
                return i
    return None

def get_doctitle(doc: str) -> str:
    '''Gets the title of a docstring.'''
    lines = (doc or '').split('\n')
    i = find_first_title(lines)
    if i is None: return ''
    return '\n'.join([l.strip() for l in lines[:i]])

def find_end_of_def(name: str, lines: list[str]) -> (int, int):
    '''Find the end of a function definition.
    '''
    for i, line in enumerate(lines):
        has_name = name in line and line.strip().startswith(name)
        if not has_name:
            continue

        # current indent level
        indlvl = len_lpad(line)
        for j in range(i+1, len(lines)):

            # get next line and its indent level
            nxtl = lines[j]         
            nxtind = len_lpad(nxtl)

            # NOTE: if same indentation level or less then it is not part of the method
            if nxtind <= indlvl:                                 
                break

            insert_loc = j + 1            
            return insert_loc, nxtind
    return None, None

# %% ../nbs/01_utils.ipynb 20
def rest_directive(s: str, double_colon: bool = True, add_space: bool = True) -> str:
    dstr = f'{DDOT} {s}'
    if double_colon:
        dstr += DCLN
    if add_space:
        dstr += SPACE
    return dstr

def rest_auto_label_footnote(label: str) -> str:
    return rest_directive(f'[#{label}]', double_colon=False, add_space=True)

# %% ../nbs/01_utils.ipynb 22
def footnotify(
    kls: type,
    attrlines: list[str],
    methlines: list[str],
    dunders: bool = False,   # include dunder methods
    abmethods: bool = False, # label abstract methods
):
    kname = kls.__name__
    fnote = f'[#{kname}]'
    fnref = f'{fnote}_'
    
    # NOTE: members may include attributes thate follow `_: KW_ONLY`
    members = inspect.getmembers(kls, predicate=lambda x: not inspect.isroutine(x))
    methods = inspect.getmembers(kls, predicate=inspect.isfunction)
    annots  = inspect.get_annotations(kls)
    
    # filter annotations to only include those not in members
    annots = {
        k: v for k, v in annots.items() 
        if k not in list(dict(members).keys()) and not isinstance(v, _KW_ONLY_TYPE)
    }

    for attr_group in [members, annots.items()]:
        for name, value in attr_group:   
            # insert location, number of indent spaces     
            insloc, nindent = find_end_of_def(name, attrlines)

            if insloc is not None:
                nstr = f'inherited from {kname}{fnref}'
                attrlines.insert(insloc, indent(nstr, nindent))

            elif not name.startswith('_'):
                attrlines.append(indent(f'{name}: {type(value).__name__}'))
                nstr = f'inherited from {kname}{fnref}'
                attrlines.append(indent(nstr, 8))

    for name, method in methods:
        signature = inspect.signature(method)
        label_abs = abmethods and getattr(method, ISABSTRACTMETHOD, None)
        abstract = f' [{ABSTRACTMETHOD}]' if label_abs else ''
        nstr = indent(f'{name}{signature}{fnref}{abstract}')
        
        # insert_loc, n_ind = find_end_of_def(name, methlines)
        insloc, nindent = find_end_of_def(name, methlines)
        if insloc is not None:
            nstr = f'inherited from {kname}{fnref}'
            methlines.insert(insloc, indent(nstr, nindent))
        elif dunders and name.startswith('__'):
            methlines.append(nstr)
        elif not dunders and name.startswith('__'):                        
            pass
        else:   
            methlines.append(nstr)

    footnote_line = f'.. {fnote} attributes and methods inherited from `{kname}`:\n'
    methlines.append(indent(f'{footnote_line}'))
    return attrlines, methlines


# %% ../nbs/01_utils.ipynb 24
def make_note_str(line: str):
    nstr = REST_NOTE + SPACE + line.strip()
    lpad = len_lpad(line)
    return indent(nstr, lpad)

def make_section_str(sec: str, n: int = 4, c: str = SPACE) -> str:
    title = sec.title()
    hline = '-' * len(title)
    return indent(f'{title}\n{hline}', n, c)


def make_inheritance_separator(kls: type = None):
    nstr = f'inherited from {kls.__name__}' if kls else 'inherited'
    nstr = indent(make_note_str(nstr))
    nstr = f'\n{nstr}'
    return nstr

# %% ../nbs/01_utils.ipynb 26
def make_deprecated_str(
    depver: str,         # deprecated version
    remver: str = None,  # removal version
    reason: str = None,  # reason for deprecation
    newway: str = None,  # new way of obtaining same functionality
    nspace: int = 10,    # number of spaces to indent
):
    '''
    Returns a string for a deprecated directive.

    Parameters
    ----------
    depver : str
        The version in which the object was deprecated.
    remver : str, optional
        The version in which the object will be removed.
    reason : str, optional
        The reason for deprecation, if this is useful information 
        (e.g., object is superseded, duplicates functionality found elsewhere, etc.)
    newway : str, optional
        The new way of obtaining the same functionality.
    nspace : int, default: 10    
        The number of spaces to indent
        
    Returns
    -------
    depstr : str
        The deprecated directive string.

    Examples
    --------
    This method was inspired rrom the Deprecation warning section:
    
    >>> """
    >>> .. deprecated:: 1.6.0
    >>>       `ndobj_old` will be removed in NumPy 2.0.0, it is replaced by
    >>>       `ndobj_new` because the latter works also with array subclasses.
    >>> """

    Using this method, the above example would be written as:

    >>> print(deprecated_str(
    >>>     '1.6.0', 
    >>>     '2.0.0', 
    >>>     '`ndobj_old` will be removed because the new version also works with array subclasses.',
    >>>     '`ndobj_new` is the replacement for `nbobj_old`.',
    >>> ))
    .. deprecated:: 1.6.0
          This will be removed in version 2.0.0.
          `ndobj_old` will be removed because the new version also works with array subclasses.
          `ndobj_new` is the replacement for `nbobj_old`.
    '''
    indent = SPACE * nspace
    depstr = REST_DEPRECATED
    depstr += f' {depver}'
    if remver:
        depstr += f'\n{indent}This will be removed in version {remver}.'
    if reason:
        depstr += f'\n{indent}{reason}'
    if newway:
        depstr += f'\n{indent}{newway}'
    return depstr

