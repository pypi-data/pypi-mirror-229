# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['ClassAttributeError', 'DynamicAttributeError', 'noop', 'optarg_fallback', 'optarg_fallback_to_clsattr',
           'DynamicAttributesMixin']

# %% ../nbs/00_core.ipynb 4
from atyp import ClsBool, AnyQ, StrQ, CallQ, ClsCallQ
from typing import Callable

# %% ../nbs/00_core.ipynb 6
class ClassAttributeError(AttributeError):
    '''Exception for non-existent class attributes.'''
    def __init__(self, cls: type, attr: StrQ = None):
        msg = f'{cls.__name__} does not have a class variable named {attr}'
        super().__init__(msg)

class DynamicAttributeError(AttributeError):
    '''Exception for invalid dynamic attributes.'''
    def __init__(self, cls: type, attr: StrQ = None):
        msg = (
            f'The dynamic attribute specified by `{cls.__name__}.{attr}`'
            f'is `None`, expected a string.'
        )
        super().__init__(msg)

# %% ../nbs/00_core.ipynb 8
def noop(x, *args, **kwargs): 
    return x

def optarg_fallback(
    arg: str,  
    flbk_val: AnyQ = None, 
    flbk_func: CallQ = noop,
    isclsfunc: bool = False, 
    isinstfunc: bool = False,
    passcls: bool = False,
    passself: bool = False,
    passargs: bool = False,
    passkwds: bool = False,
):
    '''Decorator to set default values for optional arguments based on a fallback function.
    
    Parameters
    ----------
    arg : str
        Name of the optional argument.
    flbk_val : AnyQ, optional
        Default value of the optional argument.
    flbk_func : CallQ, optional
        Function to call to generate the default value of the optional argument.
    isclsfunc : bool, optional
        Whether the decorated function is a class method.
    isinstfunc : bool, optional
        Whether the decorated function is an instance method.
    passcls : bool, optional
        Whether to pass the class as the first argument to the fallback function.
    passself : bool, optional
        Whether to pass the instance as the first argument to the fallback function.
    passargs : bool, optional
        Whether to pass the arguments to the fallback function.
    passkwds : bool, optional
        Whether to pass the keyword arguments to the fallback function.
    '''
    def decorator(func):
        def wrapper(*args, **kwargs):
            # cls or self if isclsfunc or isinstfunc respectively
            arg1st = args[0] if args else None

            # Fallback value provided directly
            if flbk_val is not None:
                kwargs.setdefault(arg, flbk_val)

            # Fallback function provided
            elif kwargs.get(arg) is None:
                params = [arg]

                if passargs:
                    params.extend(args)
                if (isclsfunc and passcls) or passcls:
                    params.insert(0, arg1st)
                if (isinstfunc and passself) or passself:
                    params.insert(0, arg1st)

                kwds = kwargs.copy() if passkwds else {}
                kwargs[arg] = flbk_func(*params, **kwds)
                
            return func(*args, **kwargs)
        return wrapper
    return decorator


def optarg_fallback_to_clsattr(arg: str):
    '''Specialized decorator for falling back to class attributes.'''
    return optarg_fallback(
        arg = arg, flbk_func = lambda self, arg: self.getclsattr(arg),
        isinstfunc = True, passself = True,        
    )

# %% ../nbs/00_core.ipynb 10
class DynamicAttributesMixin:
    '''Mixin for dynamic attribute management.
    
    Attributes
    ----------
    raisedynerr : bool
        Whether to raise an error if dynamic attributes are not found.
    toinstname : Callable, None
        Function to convert an attribute name to its instance name.
    totypename : Callable, None
        Function to convert an attribute name to its type name.
    '''
    # Whether to raise an error if dynamic attribtues are not found
    raisedynerr: ClsBool = False
    
    # the function to convert an attribute name to it's instance name e.g. `attr` -> `_attr`
    toinstname: ClsCallQ = None
    # the function to convert an attribute name to it's instance name e.g. `attr` -> `ATTR`
    totypename: ClsCallQ = None
    
    def check_dynattr_err(self, dynattr: StrQ = None) -> None:
        '''Check if dynamic attribute is valid.
        
        Parameters
        ----------
        dynattr : str, None
            Dynamic attribute name to check.
            
        Raises
        ------
        DynamicAttributeError
            If the attribute is invalid and `raisedynerr` is True.
        '''
        name = getattr(self, (dynattr or ''), None)
        if name is None and type(self).raisedynerr:
            raise DynamicAttributeError(type(self), dynattr)
            

    def getattrname(self, dynattr: str) -> StrQ:
        '''
        Get the name of the dynamic attribute.
        
        Parameters
        ----------
        dynattr : str
            The name of the dynamic attribute.
            
        Returns
        -------
        name : str, None
            The name of the dynamic attribute.
        '''
        self.check_dynattr_err(dynattr)
        return getattr(self, dynattr, None)
        
    def getdynattr(self, dynattr: str, default: AnyQ = None) -> StrQ:
        '''get dynamic attribute'''
        attr = self.getattrname(dattr)
        return getattr(self, attr, default) if attr else default

    def setdynattr(self, dynattr: str, val: AnyQ = None):
        '''set dynamic attribute'''
        attr = self.getattrname(dattr)
        if attr is None: return
        setattr(self, attr, val)

    @classmethod
    def getclsattr(cls, attr: str, default: AnyQ = None):
        '''get class attribute'''
        if not hasattr(cls, attr):
            raise ClassAttributeError(cls, attr)
        return getattr(cls, attr, default)
    
    @classmethod
    def setclsattr(cls, attr: str, val: AnyQ = None):
        '''set class attribute'''
        if not hasattr(cls, attr): return
        setattr(cls, attr, val)        

    @optarg_fallback_to_clsattr('toinstname')
    @optarg_fallback_to_clsattr('totypename')
    def getinstclsattr(self, attr: str, toinstname: CallQ = None, totypename: CallQ = None) -> AnyQ:
        '''getattr for instance and class attributes that share the same name'''        
        instattr, typeattr = f'{attr}', f'{attr}'
        if isinstance(toinstname, Callable): 
            instattr = toinstname(attr)
        if isinstance(totypename, Callable): 
            typeattr = totypename(attr)        
        return getattr(self, instattr, self.getclsattr(typeattr))
