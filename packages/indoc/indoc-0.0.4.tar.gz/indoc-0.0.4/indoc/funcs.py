# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_funcs.ipynb.

# %% auto 0
__all__ = ['get_sections', 'inherited_doc']

# %% ../nbs/02_funcs.ipynb 4
from indoc.const import (
    # explicit numpy section
    NUMPY_SECTIONS, 
    ATTRIBUTES, METHODS,
)

# %% ../nbs/02_funcs.ipynb 5
from indoc.utils import (
    indent, is_rest_title, surrounding, 
    get_doctitle, footnotify, make_section_str
)

# %% ../nbs/02_funcs.ipynb 8
def get_sections(
    doc: str,
    kls: type = None, # a subclass of the class
    cls: type = None, # the class we are decorating
    show_cls_sep: bool = False,
    cls_sep_func: callable = None,
) -> dict:
    lines = (doc or '').split('\n')
    
    section  = None
    sections = {s: [] for s in NUMPY_SECTIONS}

    # for each line in the numpy docstring
    for i, line in enumerate(lines):
        
        # If we find the start of a new section
        if line.strip() in NUMPY_SECTIONS:
            # We set the current section
            # NOTE: we are not adding the section to the sections dictionary
            section = line.strip()

        # If we find the end of a the current section (?)
        elif line.strip() == '':
            # TODO: check if this really is a transition to the next section
            above, below = surrounding(lines, i)
            section = None

        # If we are in a section
        elif section and section in sections:

            # If the line is a rest title for the current section
            if is_rest_title(section, line):
                if not show_cls_sep: continue

                # NOTE: if we append this line to sections here, we will get a duplicate hline 
                # or as shown here we include it to show that it is inherited

                # NOTE: kls == cls when we are decorating the base class so adding an 
                # inheritance separator is not necessary
                if cls and kls == cls:                  
                    continue
                
                # NOTE: The `cls_sep_func` may return multiple lines
                sep = cls_sep_func(kls)
                if isinstance(sep, str) and '\n' in sep:
                    sep = sep.split('\n')                
                for subline in sep:
                    sections[section].append(subline)

            else:
                sections[section].append(line)
                
    return sections

# %% ../nbs/02_funcs.ipynb 10
def inherited_doc(    
    cls: type, # the class we are decorating
    show_cls_sep: bool = False,
    cls_sep_func: callable = None,
    use_footnotes: bool = True,
    label_abstract: bool = True,
    include_dunders: bool = True,
) -> type:
    # start new doc with title if it exists
    new_doc = indent(get_doctitle(cls.__doc__))
    
    # get current (i.e. the subclass's) sections
    cls_sections = get_sections(
        doc = cls.__doc__,
        kls = cls, # a subclass of the class
        cls = cls, # the class we are decorating
        show_cls_sep = show_cls_sep,
        cls_sep_func = cls_sep_func,
    )
    
    for base in cls.__bases__:            

        # NOTE: I am not doing anything with the base_title
        bname = base.__name__
        base_title = get_doctitle(base.__doc__)

        # add each base's sections to new doc under according section
        base_sections = get_sections(
            doc = base.__doc__,
            kls = base, # a subclass of the class
            cls = cls,  # the class we are decorating
            show_cls_sep = show_cls_sep,
            cls_sep_func = cls_sep_func,
        )
        for section, lines in base_sections.items():
            if section in cls_sections:
                cls_sections[section].extend(lines)                


        if use_footnotes:
            attrlines, methlines = footnotify(base,
                attrlines = cls_sections[ATTRIBUTES],
                methlines = cls_sections[METHODS], 
                dunders = include_dunders, abmethods = label_abstract,
            )

            cls_sections[METHODS]    = methlines
            cls_sections[ATTRIBUTES] = attrlines 
            
    nonempty_sections = {s: l for s, l in cls_sections.items() if len(l) > 0}
    for section, lines in nonempty_sections.items():
        title = make_section_str(section)
        new_doc += f'\n{title}\n' + '\n'.join(lines) + '\n\n'

    cls.__doc__ = new_doc        
    return cls
