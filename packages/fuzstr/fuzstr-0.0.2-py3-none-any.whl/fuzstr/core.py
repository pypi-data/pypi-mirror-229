# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['fuzstr']

# %% ../nbs/00_core.ipynb 4
import re, difflib
from abc import ABC, abstractmethod

# %% ../nbs/00_core.ipynb 6
from typing import List, Tuple, Iterable
from atyp import (BoolQ, FloatQ, StrLike, StrLikeQ,)

# %% ../nbs/00_core.ipynb 7
# from aprep import aprep

# %% ../nbs/00_core.ipynb 8
from ispec import AttrPref, setkws, getattrs, kwsopt
from pstr.sens import sens
from pstr.fuzz import fuzzfind

# %% ../nbs/00_core.ipynb 10
class fuzstr(str, ABC):
    '''Fuzzy String Class

    Parameters
    ----------
    value : str
        The original string.
    icase : bool, optional
        Whether to ignore case when matching, by default True.
    ispace : bool, optional
        Whether to ignore spaces when matching, by default True.
    iunder : bool, optional
        Whether to ignore underscores when matching, by default True.
    cutoff : float, optional
        The cutoff for fuzzy matching, by default 0.8.
    '''
    # Whether to ignore case when matching
    icase:  bool  = True
    # Whether to ignore spaces when matching
    ispace: bool  = True
    # Whether to ignore underscores when matching
    iunder: bool  = True
    # The cutoff for fuzzy matching
    cutoff: float = 0.8
    
    def __new__(
        cls, 
        value: StrLikeQ, 
        icase: BoolQ   = True, # Case insensitive
        ispace: BoolQ  = True, # Space insensitive
        iunder: BoolQ  = True, # Underscore insensitive
        cutoff: FloatQ = 0.8,  # Fuzzy cutoff
        **kwargs
    ):  
        # Put all variables in a dictionary for easy access
        kws = kwargs.copy()
        kws.update(icase=icase, ispace=ispace, iunder=iunder, cutoff=cutoff)        
        
        # Create the original string        
        rawstr, newstr = value, cls.__prep__(value)        
        obj = super().__new__(cls, newstr)
        
        # Store the original string for reference
        obj.rawstr = rawstr # The raw string
        obj = setkws(obj, cls, pref=AttrPref.KOC, **kws)
        return obj

    @property    
    def clsname(self) -> str:
        return type(self).__name__

    @property    
    def attrnames(self) -> Tuple[str]:
        return ('icase', 'ispace', 'iunder', 'cutoff', )
    
    @property
    def attrs(self) -> dict:
        '''Instance parameters.'''
        return getattrs(self, self.attrnames)

    @property
    def raw(self) -> str:
        '''The raw string.'''
        return self.rawstr

    def tostr(self) -> str:
        '''Convert the instance to a string.'''
        return str(self.raw)

    def getargs(self, **kwargs) -> dict:
        '''Instance parameters with optional overrides.'''
        return kwsopt(self.attrs, **getattrs(kwargs, self.attrnames))

    @classmethod
    def tocls(cls, s: str, **kwargs):
        '''Convert the provided string to an fuzstr.'''
        return cls(s, **kwargs)

    def tosame(self, s: StrLike, **kwargs): # `fuzzify`
        '''Convert the provided string to an fuzstr with same parameters as this one.'''
        return self.tocls(s, **self.getargs(**kwargs))

    @classmethod
    def isinst(cls, other: StrLike) -> bool: # `isfuz`
        '''Check if the provided string is an instance of this class.'''
        return isinstance(other, cls)

    def sameargs(self, other: StrLike) -> bool: #  `samefuz`
        '''Check if the provided string is an fuzstr with same parameters.'''
        if self.isinst(other): return self.args() == other.args()
        return False
    
    def diffargs(self, other: StrLike) -> bool: # `difffuz`
        '''Check if the provided string is an fuzstr with different parameters.'''
        return not self.sameargs(other)

    @staticmethod
    @abstractmethod
    def __prep__(s: StrLike, icase: bool = True, ispace: bool = True, iunder: bool = True, **kwargs) -> str:
        '''Prepare a string by applying case and space insensitivity rules.'''
        return sens(s, icase, ispace, iunder)

    def prep(self, s: StrLikeQ = None) -> str:
        '''Prepare a string by applying case and space insensitivity rules.

        Parameters
        ----------
        s : StrLikeQ, optional
            The string to prepare, by default None. If `None`, the original 
            string (`self`) is used.
        
        Notes
        -----
        If no string is provided, the original string is used i.e. `self.raw`.

        See Also
        --------
        __prep__
        '''
        return self.__prep__((s or self.raw), icase=self.icase, ispace=self.ispace, iunder=self.iunder)    
    
    def find(self, strseq: Iterable[StrLike], **kwargs) -> List[str]:
        '''Find the closest matches (same-ish) in the provided sequence using fuzzy matching.
        
        See Also
        --------
        pstr.fuzzfind
        difflib.get_close_matches
        '''
        return fuzzfind(self.raw, strseq, prep=True, prepfunc=self.prep, **kwargs)
            
    def iseq(self, other: str) -> bool:
        '''Check if the provided string is an alias of this entity using fuzzy matching.'''
        strseqs = (self.prep(other), )
        matches = self.find(strseqs, n=1)
        return len(matches) > 0

    def __eq__(self, other):
        if isinstance(other, (str, type(self))):
            return self.iseq(other)
        return super().__eq__(other)

    def __str__(self):
        return self.raw

    def __hash__(self):
        return super().__hash__()
