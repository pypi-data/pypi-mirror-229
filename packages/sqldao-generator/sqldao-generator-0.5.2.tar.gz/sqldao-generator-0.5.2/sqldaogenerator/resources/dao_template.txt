"""
This file is generated by sqldao-generator; don't modify anything.
If you need to do it, you should create another class.
"""
from {base_dao_package}.{base_dao_name} import {base_dao_name}
from {entity_package}.{entity_name} import {entity_name}
from sqldaogenerator.common.Criterion import Criterion
from sqldaogenerator.common.TransactionManager import transactional


class {entity_name}Dao({base_dao_name}):

    @transactional(auto_commit=False)
    def select(self, criterion: Criterion) -> tuple[list[{entity_name}], int]:
        criterion_list = criterion.to_list()
        assert self.is_in_modules(criterion_list, {entity_name}), \
            "The expressions must be created by the {entity_name} entity."
        session = self.get_transaction()
        page = criterion.page
        query = session.query({entity_name}).filter(*criterion_list)
        if page.order_by is not None:
            orders = page.order_by.split(" ")
            query = query.order_by(eval(f"{entity_name}.{{orders[0]}}.{{orders[1]}}()"))
        total = None
        if page.page_no is not None and page.page_size is not None:
            query = query.offset((page.page_no - 1) * page.page_size).limit(page.page_size)
            total = session.query({entity_name}).filter(*criterion_list).count()
        entities = query.all()
        return entities, total or len(entities)

    @transactional()
    def insert(self, criterion: Criterion):
        session = self.get_transaction()
        entity = {entity_name}(**criterion.values)
        session.add(entity)
        session.flush()
        session.refresh(entity)
        session.expunge(entity)
        return entity

    @transactional()
    def update(self, criterion: Criterion):
        criterion_list = criterion.to_list()
        assert criterion_list is not None and len(criterion_list) > 0, \
            "Must have at least one condition in the update."
        assert self.is_in_modules(criterion_list, {entity_name}), \
            "The expressions must be created by the {entity_name} entity."
        session = self.get_transaction()
        entities = session.query({entity_name}).filter(*criterion_list).all()
        for entity in entities:
            for key, value in criterion.items():
                setattr(entity, key, value)
        return len(entities)

    @transactional()
    def delete(self, criterion: Criterion):
        criterion_list = criterion.to_list()
        assert criterion_list is not None and len(criterion_list) > 0, \
            "Must have at least one condition in the delete."
        assert self.is_in_modules(criterion_list, {entity_name}), \
            "The expressions must be created by the {entity_name} entity."
        session = self.get_transaction()
        entities = session.query({entity_name}).filter(*criterion_list).all()
        for entity in entities:
            session.delete(entity)
        return len(entities)


{entity_variable}_dao = {entity_name}Dao()
