# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['FuzstrArgs', 'fuzstr']

# %% ../nbs/00_core.ipynb 4
import re, difflib
from abc import ABC, abstractmethod

# %% ../nbs/00_core.ipynb 6
from typing import TypeAlias, Tuple, Iterable, List
from atyp import (BoolQ, FloatQ, StrLike, StrLikeQ,)

FuzstrArgs: TypeAlias = Tuple[bool, bool, bool, float]

# %% ../nbs/00_core.ipynb 7
# from aprep import aprep

# %% ../nbs/00_core.ipynb 9
class fuzstr(str, ABC):
    '''Fuzzy String Class

    Parameters
    ----------
    value : str
        The original string.
    icase : bool, optional
        Whether to ignore case when matching, by default True.
    ispace : bool, optional
        Whether to ignore spaces when matching, by default True.
    iunder : bool, optional
        Whether to ignore underscores when matching, by default True.
    cutoff : float, optional
        The cutoff for fuzzy matching, by default 0.8.
    '''
    # Whether to ignore case when matching
    icase:  bool  = True
    # Whether to ignore spaces when matching
    ispace: bool  = True
    # Whether to ignore underscores when matching
    iunder: bool  = True
    # The cutoff for fuzzy matching
    cutoff: float = 0.8
    
    def __new__(
        cls, 
        value: StrLikeQ, 
        icase: BoolQ   = True, # Case insensitive
        ispace: BoolQ  = True, # Space insensitive
        iunder: BoolQ  = True, # Underscore insensitive
        cutoff: FloatQ = 0.8   # Fuzzy cutoff
    ):
        # Create the original string
        obj = super().__new__(cls, value)
        # Store the original string for reference
        obj.rawstr = value # The raw string
        # Store the fuzzy parameters
        obj.icase  = icase  # Case insensitive
        obj.ispace = ispace # Space insensitive
        obj.iunder = iunder # Underscore insensitive
        obj.cutoff = cutoff # Fuzzy cutoff
        return obj

    @property    
    def clsname(self) -> str:
        return type(self).__name__

    @property    
    def attrnames(self) -> List[str]:
        return 'icase ispace iunder cutoff'.split()

    @property
    def raw(self) -> str:
        '''The raw string.'''
        return self.rawstr

    def tostr(self) -> str:
        '''Convert the instance to a string.'''
        return str(self.raw)

    def args(self) -> FuzstrArgs:
        '''Instance parameters.'''
        return (self.icase, self.ispace, self.iunder, self.cutoff)
    
    def optargs(
        self, icase: BoolQ = None, ispace: BoolQ = None, 
        iunder: BoolQ = None, cutoff: FloatQ = None, **kwargs
    ) -> FuzstrArgs:
        '''Instance parameters with optional overrides.'''
        inst, args = self.args(), (icase, ispace, iunder, cutoff)
        (icase, ispace, iunder, cutoff) = [i if a is None else a for (i, a) in zip(inst, args)]
        return (icase, ispace, iunder, cutoff)

    @classmethod
    def tocls(cls, s: str, icase: bool = True, ispace: bool = True, iunder: bool = True, cutoff: float = 0.8):
        '''Convert the provided string to an fuzstr.'''
        return cls(s, icase=icase, ispace=ispace, iunder=iunder, cutoff=cutoff)

    def tosame(self, s: StrLike, icase: BoolQ = None, ispace: BoolQ = None, iunder: BoolQ = None, cutoff: FloatQ = None):
        '''
        Convert the provided string to an fuzstr with same parameters as this one.

        Notes
        -----
        This function was originally called `fuzzify`.
        '''
        (icase, ispace, iunder, cutoff) = self.optargs(icase=icase, ispace=ispace, iunder=iunder, cutoff=cutoff)
        return self.tocls(s, icase=icase, ispace=ispace, iunder=iunder, cutoff=cutoff)

    @classmethod
    def isinst(cls, other: StrLike) -> bool:
        '''Check if the provided string is an instance of this class.

        Notes
        -----
        This function was originally called `isfuz`.
        '''
        return isinstance(other, cls)

    def sameargs(self, other: StrLike) -> bool:
        '''
        Check if the provided string is an fuzstr with same parameters.
        
        Notes
        -----
        This function was originally called `samefuz`.
        '''
        if self.isinst(other):
            return self.args() == other.args()
        return False
    
    def diffargs(self, other: StrLike) -> bool:
        '''
        Check if the provided string is an fuzstr with different parameters.
        
        Notes
        -----
        This function was originally called `difffuz`.
        '''
        if self.isinst(other) and not self.sameargs(other):
            return True
        return False

    @staticmethod
    @abstractmethod
    def __prep__(s: StrLike, icase: bool = True, ispace: bool = True, iunder: bool = True) -> str:
        '''Prepare a string by applying case and space insensitivity rules.'''
        if icase:
            s = s.lower()
        if ispace:
            s = re.sub(r'\s', '', s)
        if iunder:
            s = re.sub(r'_', '', s)        
        return s

    def prep(self, s: StrLikeQ = None) -> str:
        '''Prepare a string by applying case and space insensitivity rules.

        Parameters
        ----------
        s : StrLikeQ, optional
            The string to prepare, by default None. If `None`, the original 
            string (`self`) is used.
        
        Notes
        -----
        If no string is provided, the original string is used.

        See Also
        --------
        __prep__
        '''
        return self.__prep__((s or self), icase=self.icase, ispace=self.ispace, iunder=self.iunder)    
    

    @staticmethod
    def fuzzmatch(word: StrLike, possibilities: Iterable[StrLike], n: int = 1, cutoff: FloatQ = 0.8) -> List[str]:
        '''Find the closest matches in the provided sequences using fuzzy matching.
        
        Parameters
        ----------
        word : StrLike
            The word to match.
        possibilities : Iterable[StrLike]
            The sequence of possibilities to match against.
        n : int, optional
            The number of matches to return, by default 1.
        cutoff : FloatQ, optional
            The fuzzy cutoff for matching, by default 0.8.

        Returns
        -------
        List[str]
            List of closest matches.
            
        Notes
        -----
        This function was originally called `fuzz`.

        `fuzzmatch` is in essence a wrapper around `difflib.get_close_matches`. However, it will check
        if the provided word has a cutoff parameter and use it if `cutoff is None`.

        See Also
        --------
        find
        findsame
        difflib.get_close_matches
        '''        
        return difflib.get_close_matches(word, possibilities, n=n, cutoff=cutoff)

    
    def findsame(self, s: StrLike, strseq: Iterable[StrLike], prep: BoolQ = True, **kwargs) -> List[str]:
        '''Find the closest matches (same-ish) in the provided sequence using fuzzy matching.
        
        Notes
        -----
        `fuzzmatch` is very similar to `fuzzmatch` (a wrapper around `difflib.get_close_matches`). 
        However, it will call `prep` on the provided string and the provided sequence.

        See Also
        --------
        find
        fuzzmatch
        difflib.get_close_matches
        '''
        string = self.prep(s)
        nmatch = kwargs.get('n', getattr(self, 'n', 1))
        cutoff = kwargs.get('cutoff', getattr(self, 'cutoff', 1))

        # Find the closest match using difflib
        if not isinstance(strseq, Iterable):
            strseq = (strseq, )

        if prep:        
            strseq = list(map(self.prep, strseq))

        matches = self.fuzzmatch(string, strseq, n=nmatch, cutoff=cutoff)
        return matches

    def find(self, seq: Iterable[StrLike], **kwargs) -> List[str]:
        '''Find the closest matches (same-ish) in the provided sequence using fuzzy matching.
        
        Notes
        -----
        `find` calls `fuzzmatch` with the instance string and the provided sequence.

        See Also
        --------
        fuzzmatch
        findsame
        difflib.get_close_matches
        '''
        return self.findsame(self, seq, **kwargs)
            
    def iseq(self, other: str) -> bool:
        '''Check if the provided string is an alias of this entity using fuzzy matching.'''
        strseqs = (self.prep(other), )
        matches = self.find(strseqs, n=1)
        return len(matches) > 0

    def __eq__(self, other):
        if isinstance(other, (str, type(self))):
            return self.iseq(other)
        return super().__eq__(other)

    def __hash__(self):
        return super().__hash__()
