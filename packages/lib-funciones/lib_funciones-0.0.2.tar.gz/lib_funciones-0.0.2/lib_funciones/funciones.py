# -*- coding: utf-8 -*-
"""ajuste_lineal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_NI2uZ_qk3jrK9Yq3huqyeQRjuvIC66B
"""



import matplotlib.pyplot as plt #matplotlib contiene funciones necesarias para graficar. Los detalles se pueden consultar en https://matplotlib.org/stable/plot_types/index.html documentación
import numpy as np #numpy contiene las definiciones de las funciones matemáticas más comunes como trigonométricas, exponenciales, etc
from scipy.signal import find_peaks #contiene funciones de ajuste y minimización
import pandas as pd #funciones necesarias para manipular datos numéricos externos
from google.colab import drive
from scipy.optimize import curve_fit #https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html

def ajuste_lineal(subset , x , y , err_x, err_y, powx , powy , titulo , xlabel , ylabel , leyenda , k):
    #el módulo "ajuste_lineal" toma como parámetros el set de datos que pongamos en la primera entrada. Utiliza los valores powx , powy para reescalear los datos (si no fuese necesario, ingresar 0).
    #le pone título con titulo al gráfico y nombres a los ejes con xlabel ylabel.

    datos = subset
    x_data = np.array(datos[x])
    y_data = np.array(datos[y])
    errx = np.array(datos[err_x])
    erry = np.array(datos[err_y])

    #Reescalamos los valores

    x_data = np.array(x_data/pow(10,powx))
    y_data = np.array(y_data/pow(10,powy))
    errx = np.array(errx/pow(10,powx))
    erry = np.array(erry/pow(10,powy))

    #Conversion de datos a float64
    y_data = np.float64(y_data)
    x_data = np.float64(x_data)
    erry = np.float64(erry)
    errx = np.float64(errx)

    print("Periodo:",x_data)
    print("Semieje:",y_data)
    print("Incertezas en x:",errx)
    print("Incertezas en y:",erry)

    def model_f(x,m,b): #definimos la función a ajustar
        return m*x + b

    sig = np.absolute(erry) # En el array sig guardamos los errores en y (su valor absoluto) para pasar al ajuste

    popt, pcov = curve_fit(model_f, x_data , y_data , sigma = sig , absolute_sigma=True ) # Por defecto los valores iniciales con los que comienza el ajuste es 1, si queremos utilizar otros debemos agregar ,p0=[0.74,0.866,10,1.45]

# popt nos da un array con los parámetros de ajuste, en el orden que los pusimos en la función func (o sea, primero va a aparecer m y después b)
# pcov es la matriz de covarianza; en las líneas que siguen vamos a ver cómo obtener los errores de los parámetros de ajuste a partir de ésta

    print("Parámetros del ajuste:" , popt)

    perr = np.sqrt(np.diag(pcov)) # Obtenemos las incertezas del ajuste (también en el orden en que aparecen en la función) a partir de pcov
    print("Incertezas respectivas asociadas:",perr)

    print("Matriz de covarianza:" , pcov)

    print("m=", popt[0] , "+/-" , perr[0])

    print("b=", popt[1] , "+/-" , perr[1])

    #Grafiquemos la funcion ajustada y los puntos experimentales

    m_opt , b_opt = popt
    x_func = np.linspace(min(x_data) , max(x_data) , 100)
    y_func = model_f(x_func,m_opt,b_opt)

    plt.scatter(x_data,y_data , marker='.' , c='black' , label='Datos')
    plt.errorbar(x_data,y_data,xerr=errx,yerr=erry,ecolor='g',fmt='none' , lw=0.5)
    plt.xlabel(xlabel , fontsize=16)
    plt.ylabel(ylabel , fontsize=16)
    plt.title( titulo , fontsize=18)
    plt.plot(x_func , y_func , c='r' ,lw=1.5 , label= leyenda)
    plt.legend()
    plt.show()

    # Para sacar R^2: (ver tratamiento de datos I)
    r = y_data - model_f(x_data, *popt) # Resta uno a uno (y guarda en un nuevo array) y_i con f(x_i) (evaluada en los parámetros que arrojó el ajuste)
    SCR = np.sum(r**2) # Obtenemos la suma de los cuadrados de los residuos
    SCT = np.sum((y_data - np.mean(y_data))**2) # Obtenemos la suma de los cuadrados totales
    r_squared = 1-(SCR / SCT) # Calculamos R^2
    chisq = sum((r/sig)**2) #Chi cuadrado pesado
    chisq_reducido = chisq / (len(x_data)-len(popt)) # Dividimos la suma de los cuadrados de los residuos por el número de puntos menos el número de parámetros
    print("Chi cuadrado pesado:",chisq)
    print("Chi cuadrado reducido:",chisq_reducido)
    print('R^2=',r_squared)


    #GRÁFICO DE RESIDUOS

    plt.scatter(np.log(x_data) , r)

    return()

elipticos="https://docs.google.com/spreadsheets/d/e/2PACX-1vT8eYuvu40o5k6RuNvl9Wp9WG8ujaLmhMOxFwVdGNZez-4mK1VgKMg7bSAT3RPvSSrjd5Gr9HhsxhWt/pub?gid=186334054&single=true&output=tsv"
datosElipticos=pd.read_csv(elipticos,sep="\t")

ajuste_lineal(datosElipticos , "t^2" , "a^3" , "errp^2" , "errs^3" , 8 , 21 , "Satélites de órbita elíptica" , '$T^2 (10^{8}s^2)$' , '$a^3 (10^{21}m^3)$' , '$a^3 = k \cdot T^2 + b$' , 'k=423453421354ms')