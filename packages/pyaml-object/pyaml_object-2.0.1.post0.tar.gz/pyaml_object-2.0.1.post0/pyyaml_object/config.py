from __future__ import annotations
from typing import TYPE_CHECKING
from .utils import Node
import yaml

if TYPE_CHECKING:
    from typing import Any

    TSTACK = list[tuple["Node", dict[Any, Any]]]


class Config:
    """
    Read the yaml configuration file and assign it dynamically
    to a tree of nodes with a root at its top.

    :param filepath: the relative/absolute path of\
                    the yaml file to parse.
    """

    def __init__(self, filepath: str) -> None:
        self._filepath = filepath

    @property
    def filepath(self) -> str:
        """
        Get the file path.

        Parameters:
        ----
            None

        Returns:
        ----
            str: the file path
        """
        return self._filepath

    def read(self, parent: Node = Node()) -> Node:
        """
        Parse the file and return the root node.

        Parameters:
        ----
            parent: the root node

        Returns:
        ----
            Node: the root node
        """
        data = self._read_file()
        stack = [(parent, data)]
        self._dfs(stack)
        return parent

    def _read_file(self) -> dict[Any, Any]:
        """
        Parse the yaml file with the yaml package.

        This method is used for internal setup. Its signature
        may change at any time.

        Parameters:
        ----
            None

        Returns:
        ----
            dict[Any, Any]: the parsed data

        Raises:
        ----
            EmptyFileError: if the file is empty
        """
        with open(self._filepath, "r") as f:
            data = yaml.safe_load(f)
            if len(data) == 0:
                raise EmptyFileError()
        return data

    def _dfs(self, stack: TSTACK) -> None:
        """
        Apply DFS to dynamically chain the nodes given the structure of
        the data generated by the yaml package.


        This method is used for internal setup. Its signature
        may change at any time.

        Parameters:
        ----
            stack: the stack of nodes and dictionary to \
                    respectively link and iterate through.

        Returns:
        ----
            None
        """
        while stack:
            root, data = stack.pop()
            self._iterate_and_attach_to_root_node(root, data, stack)

    def _iterate_and_attach_to_root_node(
        self, root: Node, data: dict[Any, Any], stack: TSTACK
    ) -> None:
        """
        Iterate through the branches(subdictionaries) of
        the dictionary and attach them to the parent node.

        This method is used for internal setup. Its signature
        may change at any time.

        Parameters:
        ----
            root: the parent node
            data: the dictionary to iterate through
            stack:  the stack of nodes and dictionary to \
                    respectively link and iterate through.

        Returns:
        ----
            None

        """
        for x in data:
            if isinstance(data[x], dict):
                child_node = Node()
                setattr(root, x, child_node)
                stack.append((child_node, data[x]))
            else:
                setattr(root, x, data[x])

    def __str__(self) -> str:
        return f"Config(filepath={self.filepath})"

    def __repr__(self) -> str:
        return f"Config(filepath={self.filepath})"


class EmptyFileError(Exception):
    """
    Exception raised when the data returned by the
    yaml package is empty.
    """

    def __init__(self, message: str = "Empty file") -> None:
        super().__init__(message)
